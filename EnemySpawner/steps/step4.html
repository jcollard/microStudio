<div class="step-content">
    <h2>Step 4: Object Pooling Optimization</h2>

    <p>Your <code>spawn_enemy()</code> function works great, but there's a hidden problem. Every time you call it, a new enemy is added to the <code>enemies</code> table. After spawning and destroying hundreds of enemies during gameplay, the table fills with destroyed enemies that just sit there taking up memory.</p>

    <div class="info-box">
        <h3>Object Pooling</h3>
        <p><strong>Problem:</strong> Spawning 100 enemies over 5 minutes creates 95 destroyed entries sitting in memory, wasting resources.</p>
        <p><strong>Solution:</strong> Before creating a new enemy, check for destroyed ones and reuse them by resetting properties (<code>isDestroyed = false</code>, new position, velocity).</p>
        <p><strong>Benefit:</strong> Table stabilizes at a reasonable size instead of growing infinitely.</p>
    </div>

    <h3>Your Task</h3>

    <p>Modify your <code>spawn_enemy()</code> function to implement object pooling:</p>

    <ol>
        <li>At the start of the function, loop through the <code>enemies</code> table</li>
        <li>Look for an enemy where <code>isDestroyed == true</code></li>
        <li>If found: Reset that enemy's properties and <code>return</code> early</li>
        <li>If not found: Create a new enemy (keep the existing code)</li>
    </ol>

    <h3>The Changes</h3>

    <p>Here's how your <code>spawn_enemy()</code> function evolves with object pooling:</p>

    <div id="spawn-enemy-diff"></div>

    <script>
        const oldSpawn = `function spawn_enemy()
  local size = SIZES[math.random(1, 5)]
  local sprite_name = ENEMY_SPRITES[math.random(1, 5)]

  local enemy = create_enemy(sprite_name, size, size)

  enemy.x = math.random(-100, 100)
  enemy.y = 100
  enemy.vx = math.random(-10, 10) / 10
  enemy.vy = -1
end`;

        const newSpawn = `function spawn_enemy()
  -- OBJECT POOLING: Try to find a destroyed enemy to reuse
  local enemy = nil

  for ix, e in pairs(enemies) do
    if e.isDestroyed then
      enemy = e
      break  -- Found one! Stop searching
    end
  end

  -- Generate random properties
  local size = SIZES[math.random(1, 5)]
  local sprite_name = ENEMY_SPRITES[math.random(1, 5)]

  -- If no destroyed enemy found, create a new one
  if enemy == nil then
    enemy = create_enemy(sprite_name, size, size)
  end

  -- Set/reset properties (works for both new and reused enemies)
  enemy.sprite = sprite_name
  enemy.width = size
  enemy.height = size
  enemy.x = math.random(-100, 100)
  enemy.y = 100
  enemy.vx = math.random(-10, 10) / 10
  enemy.vy = -1
  enemy.isDestroyed = false
end`;

        renderDiffBlock('spawn-enemy-diff', oldSpawn, newSpawn, 'Add object pooling to spawn_enemy()');
    </script>


    <h3>Testing</h3>

    <p>Verify pooling: <code>print(#enemies)</code> before and after spawning. Table size should stabilize as destroyed enemies get reused.</p>

    <div id="test-commands"></div>

    <script>
        const testCommands = `// Check enemy count
print(#enemies)

// Destroy some, then spawn more
spawn_enemy()
spawn_enemy()

// Check again - should be similar
print(#enemies)`;

        renderCodeBlock('test-commands', testCommands, 'lua');
    </script>

    <div class="success-box">
        <h3>Object Pooling</h3>
        <p>You've implemented a professional optimization technique used in Unity, Unreal Engine, and AAA games. Object pooling prevents memory bloat, improves performance, and enables scalability for bullets, particles, enemies, and any frequently spawned objects.</p>
    </div>
</div>

<style>
/* Disable copying for diff block - students should type the code themselves */
.step-content .diff-block-wrapper .copy-btn {
    display: none;
}

.step-content .diff-block-wrapper .line-content {
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}

.step-content .diff-block-wrapper .diff-lines {
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}
</style>
