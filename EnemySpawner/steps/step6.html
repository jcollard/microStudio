<div class="step-content">
    <h2>Step 6: Auto-Spawn After All Enemies Destroyed</h2>

    <p>You now have a function that can detect when all enemies are destroyed. But what happens next? In most games, destroying all enemies triggers something—a victory screen, a new wave, or in this case, automatic spawning to keep the challenge going.</p>

    <div class="info-box">
        <h3>Event-Driven Gameplay</h3>
        <p><strong>Event-driven programming</strong> means your game reacts to conditions and triggers actions automatically.</p>
        <p><strong>The pattern:</strong></p>
        <ol>
            <li><strong>Check a condition</strong> - "Are all enemies destroyed?"</li>
            <li><strong>Trigger an action</strong> - "Spawn a new enemy!"</li>
            <li><strong>Game responds dynamically</strong> - Player never runs out of enemies to fight</li>
        </ol>
        <p><strong>Why this matters:</strong> Event-driven systems create dynamic, responsive gameplay that reacts to player actions without manual intervention.</p>
    </div>

    <h3>Your Task</h3>

    <p>Update your <code>update_enemies()</code> function to automatically spawn a new enemy when all enemies are destroyed.</p>

    <p><strong>Requirements:</strong></p>
    <ol>
        <li>At the END of <code>update_enemies()</code>, add a check for <code>all_enemies_destroyed()</code></li>
        <li>If it returns <code>true</code>, call <code>spawn_enemy()</code></li>
        <li>This creates a continuous loop: destroy all enemies → spawn new enemy → repeat</li>
    </ol>

    <h3>The Changes</h3>

    <p>Here's how your <code>update_enemies()</code> function evolves with auto-spawning:</p>

    <div id="update-enemies-diff"></div>

    <script>
        const oldUpdate = `function update_enemies()
  for ix, enemy in pairs(enemies) do
    if not enemy.isDestroyed then
      enemy.x = enemy.x + enemy.vx
      enemy.y = enemy.y + enemy.vy

      enemy.rotation = enemy.rotation + enemy.rotation_speed

      if enemy.x < -100 then enemy.vx = -enemy.vx end
      if enemy.x > 100 then enemy.vx = -enemy.vx end
      if enemy.y < -100 then enemy.vy = -enemy.vy end
      if enemy.y > 100 then enemy.vy = -enemy.vy end
    end
  end
end`;

        const newUpdate = `function update_enemies()
  for ix, enemy in pairs(enemies) do
    if not enemy.isDestroyed then
      enemy.x = enemy.x + enemy.vx
      enemy.y = enemy.y + enemy.vy

      enemy.rotation = enemy.rotation + enemy.rotation_speed

      if enemy.x < -100 then enemy.vx = -enemy.vx end
      if enemy.x > 100 then enemy.vx = -enemy.vx end
      if enemy.y < -100 then enemy.vy = -enemy.vy end
      if enemy.y > 100 then enemy.vy = -enemy.vy end
    end
  end

  -- NEW: Check if all enemies are destroyed
  if all_enemies_destroyed() then
    spawn_enemy()  -- Spawn one new enemy
  end
end`;

        renderDiffBlock('update-enemies-diff', oldUpdate, newUpdate, 'Add auto-spawn check to update_enemies()');
    </script>

    <p><strong>How it works:</strong> Every frame, <code>update_enemies()</code> checks if all enemies are destroyed. If yes, it spawns a new one immediately—creating continuous challenge.</p>

    <h3>Testing</h3>

    <p>Play the game—destroy enemies and watch new ones spawn immediately at the top. Spawning is instant and continuous.</p>

    <h3>Try It Yourself</h3>

    <p>Play the game below to see auto-spawning in action. Destroy all enemies and watch new ones spawn immediately:</p>

    <div id="step6-demo" style="margin: 10px 0;"></div>

    <script>
        createLazyEmbed('step6-demo', 'https://microstudio.io/jocolloman/spawningenemies6/HV7FFXYR/', 400);
    </script>

    <div class="success-box">
        <h3>Event-Driven Gameplay</h3>
        <p>You've implemented reactive, event-driven architecture—code that automatically responds to game state. This pattern enables continuous challenge and is used in Vampire Survivors, Call of Duty Zombies, and Halo.</p>
    </div>
</div>

<style>
/* Disable copying for diff block - students should type the code themselves */
.step-content .diff-block-wrapper .copy-btn {
    display: none;
}

.step-content .diff-block-wrapper .line-content {
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}

.step-content .diff-block-wrapper .diff-lines {
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}
</style>
